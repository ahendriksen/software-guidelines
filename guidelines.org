#+TITLE: Software Guide (CWI CI Group)
#+AUTHOR: Jan-Willem Buurlage, Allard Hendriksen

* Introduction
This document consists of two parts. In the first part, we suggest useful tools,
a good project structure, and some further guidelines, for sharing your software
projects. In some sense, it is a checklist for your software package to make
sure that it is easy to use for others, yet allows you to keep the freedom to
develop your software further. The second part, /selected topics/, is a how-to guide for common tasks that you
may need to perform while working on software.

These notes are not intended to teach you the basics of programming, source
control, or for example using Linux. Instead, it is about everything you need /after/
you become a capable programmer, when you start producing software that becomes
useful for others.

One question we should answer before diving in deep, is /why?!/. Indeed, why
should we put so much effort in our software. We are, after all, scientists --
not software developers! We believe there are many reasons why we /should/ take
care in sharing our scientific software, some of them we list below.

- *Collaborations within the group*. Although everyone in the CI CWI group are
  individual researchers, our work has a lot in common. Most of us work on
  algorithms, target the same kind of data set, and often face the same
  problems. For example, more often than not, an issue that you are facing has
  already been tackled by someone before. Sharing our solutions means not having
  to reinvent the wheel. Furthermore, someone else their expertise may push your
  research further. Whether this means a new application of a neural network
  structure, combining algorithms together for even better reconstructions, or
  simply using a method you developed for the reconstruction of data recorded in
  our lab.
- *Collaborations with other groups.* The CI CWI group takes a unique position
  in research -- somewhere in between the hardcore mathematics, and the more
  experimental side of imaging. With our software, we can help bridge the gap
  between experimentalists (who are often still using what we consider ancient
  methods), and algorithm developers (who can be out of touch with the demands
  and requirements of real-world imaging experiments), by working together with
  both sides of this spectrum.
- *Publicity*. Putting out software that is being used by others gives a lot of
  exposure to yourself as a researcher, and the group as a whole. For example,
  ASTRA has been an important part of our public identity.
- *Real-world impact of your research.* Unfortunately, writing a beautiful
  article outlining all the ins and outs of your method does not mean that it
  will also be picked up and used by others. Time is scarce for everyone in
  science, and anything beyond the most trivial algorithm will most likely not
  be reimplemented outside our own research group. Publishing software alongside
  an article makes it /much/ easier for others to use and apply your methods.
- *Scientific output.* Slowly but surely, software itself is being recognized as
  scientific output. There are many journals and conferences dedicated to
  scientific software.

It can be intimidating to share your software with colleagues, let alone to
release it to the public. We always want to /*clean up the code, and fix this
last thing*/ before we share it. However, especially since very few of us (if
any) are trained as software engineers, it is not always clear what it means to
develop good, or /clean/, software. This means that a lot of software is kept
private until it is done, and regrettably this often means it is kept private
indefinitely.

Hopefully, after reading the next section, you will be fully equipped to turn
your software projects into clear, clean and usable packages. Our intention is
to ease the transition of your project from something that is written primarily
for yourself, to something others can also use.
* Anatomy of a software project
Let us assume that you have developed an image reconstruction algorithm. You
have designed your numerical experiments, and implemented them in Python
(perhaps on top of the ASTRA toolbox).

In the most extreme case, the result is a single script. This script contains
for example some classes, functions and some code that applies them to a data
set.

Here, we will transform this script into a software package that is installable
and usable by others, and maintainable and testable by you, the developer. We
will take the following steps, which we will explain in detail later. (1)
*Update project structure*. A software project consists of more than just the
code. In should also include additional files, containing additional information
for the user. (2) *Add documentation*. Since you developed the software, you
know exactly how it works (and how it doesn't). Unfortunately, your users cannot
read your mind. Minimally, you should provide some basic information on how to
install and use your software, as well as what your users are allowed to do with
it. (3) *Add files for distribution*. Before you can release your software into
the wild, you need to add build files, and license. (4) *Release the software*.
With a good structure, documentation and distribution files in place -- we are
ready for release. We add release notes to the project, and assign a version to
the software. (5) *Further development*. Unfortunately, having users also means
having some responsibility. Luckily, with the setup we recommend, you can
continue developing your software without frustrating your users by following a
small set of rules.

We will first discuss the steps, and it is not written to /following along as
you read/, but rather to give an overview of what a minimal software package
consists of. After this initial discussion, we will provide you with more detailed
information on how to realize these steps for your software, as most of the
steps can be automated.

** Update project structure
First, we need to convert our code into a clean and predictable structure. The
recommended structure depends mainly on the programming language used. We only
consider Python software for now, but we will discuss other languages later. Our
hypothetical software package will be called =hsp=, for hypothetical software
package.

We will first set up our directory as follows:
#+BEGIN_SRC bash
├── example
│   └── run_on_data.py
└── hsp
    ├── hsp.py
    └── __init__.py
#+END_SRC

Here, =hsp.py= contains functions and classes, while =run_on_data.py= contains
code applying them to data. Note in bigger projects you can split =hsp.py=
further into multiple files, grouping them together by functionality. The file
=__init__.py= ties them together. There can also be multiple examples.

With this structure, we can use =import hsp= from scripts residing at our root
folder. Later we will set our package up so that you can run this import
statement from anywhere.
** Add documentation
There are two classes of documentation. First, there is usually a readme file
called =README.md=, containing some basic information on the project. Second, detailed
documentation is provided on a separate webpage (hosted online or shipped
alongside the software). We will discuss a good way to set up initial
documentation.

The readme file is comparable to the metadata and abstract of an article. It
should provide a potential user with all the information he needs to decide
whether to use your software. Like writing good abstracts, writing good readme
documents is an art form. At the minimum, it should contain the following. (1)
The name of your software package, together with a short (one or two sentences)
summary of what it does. (2) Information on how to install the software. If it
is a software library, it is usually a good idea to show a short example of code
written on top of the library. (3) Information on the authors, the license, how
to contribute, and potentially what article to cite if people use your software.

The more detailed documentation can contain the README as a landing page, but
typically takes a more /tutorial-like/ approach to describe the software.
Usually, this means explaining how to do some example task with the software, or
explaining the example code that is shipped alongside the library. The example
code itself can also be considered documentation, and can usually be a stripped
down version of the code you use yourself for e.g. numerical experiments.
Furthermore, the documentation should provide an API overview, documenting all
the classes and functions you expose to the user. This overview can be generated
automatically from your code, using function signatures and optional
/docstrings/ that you may have written. For Python projects, we recommend using
Sphinx to generate the documentation.
** Add files for distribution
Next, you should allow yourself and your users to use your package by a simple
=import= statement. For this, you can include a =setup.py= for =setuptools=,
allowing your users to do a =pip install=. You can also add support for =conda=
by including some basic =.yaml= files.

You should to include a =LICENSE.md= file letting our users know what they are
allowed to do with our software. Typically, software written by our group is
released under the GPL.
** Release the software
Releasing your software does not only mean that it is made available publicly.
It means to provide a fixed, frozen version of the code that has no known bugs,
and to assign it a version number. An initial version number can be =v0.0.1=.

This is an important service to your potential users, because it gives them a
predictable state of your code to fall back on. If you decide to further develop
your code, you can do this freely without worrying about breaking your users'
codes, because they can depend on this fixed release.

This brings us to another important file, the release notes, which are contained
in a file =CHANGELOG.md=. For the initial release, this file does not much
information. Maybe a notice that it is the first public release, and the date at
which it is published. However, as you add, amend, and change your software, you
may want to release a next version, say =v0.0.2=. In the release notes, you can
let the user know what has changed, and they should be able to see immediately
if they should expect any difficulties when upgrading to the new version.

We recommend using GitHub to publish your software. GitHub has a good mechanism
for managing releases. Simply click on the /releases/ button, and create a new
release. Provide a tag, name, and some basic information -- and GitHub will
automatically mark the current state of the software as a new release. Next, you
can upload the new release to Anaconda and/or PyPI.
** Further development
Now that your software is out in the public, making big changes to your software
probably means breaking your users code.

As a courtesy to your users, whenever you add, change or remove something add a
line to your change log describing what is new.

When releasing your new software, choose a new version number according to
semantic versioning. In brief, when choosing a new number =vX.Y.Z= increment =Z=
if you are fixing incorrect behaviour, =Y= if you are adding new functionality
but user code should not break, and =X= if you make major changes that can break
user code. This gives your users a lot of information on the new release simply
by looking at the version unmber: they can always safely upgrade to your new
release if =X= is unchanged, and should check what's new when either =X= or =Y=
is increased.
** Putting theory to practice: converting your code to a software package
Instead of performing all the steps outlined above manually, the easiest way to
set up your project correctly is by using the =cookiecutter= template we
provide.
* Selected topics
** Coding standards
*** Python
**** PEP8
**** [[https://github.com/google/yapf][yapf]]
*** C/C++
**** =clang-format=
**** =clang-tidy=
**** Sensible compile flags
***** =-Wall=
***** =-Werror=
***** =-Wfatal=
***** ...
** Distributing software
*** Python
- =distutil=
- How to define and distribute a conda package
*** C/C++
***** Modern CMake
****** C++ Weekly, [[https://www.youtube.com/watch?v=HPMvU64RUTY][Intro to CMake]]
****** [[https://llvm.org/docs/CMakePrimer.html][CMakePrimer (LLVM)]]
****** [[https://www.youtube.com/watch?v=eC9-iRN2b04][CppCon 2017: Mathieu Ropert “Using Modern CMake Patterns to Enforce a Good Modular Design”]]
****** [[https://www.youtube.com/watch?v=bsXLMQ6WgIk][C++Now 2017: Daniel Pfeifer “Effective CMake"]]
****** [[https://foonathan.net/blog/2016/07/07/cmake-dependency-handling.html][Dependency management CMake/Git]]
Example:
#+BEGIN_SRC cmake
find_package(ZeroMQ QUIET)

if (ZeroMQ_FOUND)
    add_library(zmq INTERFACE)
    target_include_directories(zmq INTERFACE ${ZeroMQ_INCLUDE_DIR})
    target_link_libraries(zmq INTERFACE ${ZeroMQ_LIBRARY})
else()
    message("'zmq' not installed on the system, building from source...")

    execute_process(COMMAND git submodule update --init --remote -- ext/libzmq
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})

    set(ZMQ_BUILD_TESTS OFF CACHE BOOL "disable tests" FORCE)
    set(WITH_PERF_TOOL OFF CACHE BOOL "disable perf-tools" FORCE)
    add_subdirectory(${CMAKE_SOURCE_DIR}/ext/libzmq)
    set(ZMQ_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/ext/libzmq/include)

    # ZeroMQ names their target libzmq, which is inconsistent => create a ghost dependency
    add_library(zmq INTERFACE)
    target_link_libraries(zmq INTERFACE libzmq)
endif()
#+END_SRC
****** https://foonathan.net/blog/2018/10/17/cmake-warnings.html
***** Dynamically linked dependencies
Three places that a binary looks for shared dependencies
1. =LD_LIBRARY_PATH=
2. =rpath= encoded in binary
3. system default paths

Danger of (1) is that it overrides the specific dependencies of all binaries run.

For shared systems, or non-root users, (3) can be a problem.

For 2 you proceed as follows:
- set =LD_RUN_PATH= to something hardcoded
- use =-R= in gcc

To check the =RPATH= in a binary on Linux, use =readelf -d <binary>=.

To list all dynamic dependencies, use =ldd <binary>=

See also: [[https://www.eyrie.org/~eagle/notes/rpath.html]].
***** Python bindings
****** =pybind11=
Adding Python bindings to C++ code is straightforward with pybind11. A good
setup is as follows. (All relative to the root folder of the C++ project, which
I call =your_project= here)
******* Add pybind11 as a git submodule
#+BEGIN_SRC bash
git submodule add https://github.com/pybind/pybind11.git ext/pybind11
#+END_SRC
******* Set up the Python bindings
Make a directory =python=, containing at least three files:
******** =python/src/module.cpp=
This contains the actual bindings, an example is like this:
#+BEGIN_SRC cpp
#include <pybind11/pybind11.h>
namespace py = pybind11;

#include "your_project/your_project.hpp"

using namespace your_project;

PYBIND11_MODULE(py_your_project, m) {
    m.doc() = "bindings for your_project";

    py::class_<your_project::object>(m, "object");
}
#+END_SRC
******** =python/your_project/__init__.py=
The entry point for the Python specific code of your project. Also reexports
symbols from the generated bindings.
#+BEGIN_SRC python
from py_your_project import *
#+END_SRC
******** =python/CMakeLists.txt=
You can build the bindings using CMake.
#+BEGIN_SRC cmake
set(BINDING_NAME "py_your_project")
set(BINDING_SOURCES "src/module.cpp")

set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")

pybind11_add_module(${BINDING_NAME} ${BINDING_SOURCES})

target_link_libraries(${BINDING_NAME} PRIVATE your_project)
#+END_SRC
******* Add it as a subdirectory
In the main =CMakeLists.txt= of your project, add the Python folder:
#+BEGIN_SRC cmake
...
add_subdirectory("ext/pybind11")
add_subdirectory("python")
#+END_SRC
Now, the python bindings will be built alongside your project.
** Documentation
*** Python
**** Sphinx
***** Basic documentation generation
- http://www.sphinx-doc.org/en/master/
#+BEGIN_SRC bash
pip install -U Sphinx
sphinx-apidoc -F -o docs
cd docs
make html
#+END_SRC
- Theme: https://github.com/rtfd/sphinx_rtd_theme
***** Publishing on gh-pages
Two options:
- =docs/= folder
- =gh-pages= branch
https://help.github.com/articles/creating-project-pages-using-the-command-line/
*** C/C++
- http://www.sphinx-doc.org/en/master/
- =mkdocs=
- =breathe=
- =doxygen=
** Relevant links
- *Writing documentation*: http://stevelosh.com/blog/2013/09/teach-dont-tell/
- *Semantic versioning*: http://semver.org/
- *Writing good commit messages*: http://chris.beams.io/posts/git-commit/
- *Change log*: http://keepachangelog.com/
- *Branching model*: http://nvie.com/posts/a-successful-git-branching-model/
- UCL BUG coding standards (sent by Felix)
** Editors
** VIM
** Emacs

** Python
*** CONDA package
**** Publishing to cicwi
Willem Jan:
#+BEGIN_QUOTE
Goed idee. Ik heb een cicwi organization aangemaakt, waarvan voorlopig
Allard en ik owners zijn. Het gaat niet met een shared password, maar
door anaconda-accounts rechten te geven binnen de cicwi organization
door accounts aan de 'Owners' (admin) of 'Packagers' (read/write)
group toe te voegen.

Een package uploaden gaat dan met:
#+END_QUOTE

#+BEGIN_SRC sh
anaconda upload --user cicwi package.tar.bz2
#+END_SRC

Zie https://docs.anaconda.com/anaconda-cloud/user-guide/tasks/work-with-organizations/ .

*** Documentatie met sphinx

On stackoverflow: [[https://stackoverflow.com/a/24385103][What is the docstring format in Python?]]
*** Test my python code
Pytest is a popular python testing framework. It has some dependency
injection thingies going on, but most importantly it contains code to
compare numbers [[https://docs.pytest.org/en/latest/reference.html#pytest-approx][approximately]].

https://docs.pytest.org/en/latest/
*** Use bumpversion
Changing the version of a python package is a pain. There are python
versions in =setup.py=, =__init__.py=, and in =conda/meta.yaml=. This
is all very confusing and annoying. Therefore, we have a program
called bumpversion that does this for you.
** C++
*** CMAKE
*** Python bindings for C++
** Git
*** Good commit messages
*** Git branching model
*** Release on GitHub
** General
**** Write a readme
[[https://github.com/LappleApple/feedmereadmes/blob/master/README-maturity-model.md][This github repo]] contains a useful model of maturity levels for a
project's README.md file. It defines both the current level of
maturity of a README and gives pointers on how to improve.
**** Use module load
**** Use github pages with sphinx
**** Cookiecutter: project templates
Cookiecutter is a popular way to kickstart a python project. It fills
in all the boilerplate.

Cookiecutter templates:
- [[https://github.com/conda/cookiecutter-conda-python/tree/master/%257B%257Bcookiecutter.repo_name%257D%257D][conda]]
- [[https://github.com/mckaymatt/cookiecutter-pypackage-rust-cross-platform-publish][rust in python cross platform publish]]
